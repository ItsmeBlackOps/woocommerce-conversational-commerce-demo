import OpenAI from "openai";
import { loadData, applyStoreOverride } from "./data/loaders.js";
import { searchProducts } from "./tools/products.js";
import { routeToPage } from "./tools/pages.js";
import { recommendFromCart } from "./tools/cart.js";
import { recommendForIntent } from "./tools/intent.js";
import { shippingEstimate } from "./tools/shipping.js";
import { faqAnswer } from "./tools/faq.js";
import { includesAny, normalizeText } from "./utils/text.js";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const DEFAULT_MODEL = process.env.OPENAI_MODEL || "gpt-4.1";

const RESPONSE_SCHEMA = {
  type: "object",
  properties: {
    reply: { type: "string" },
    suggestedLinks: {
      type: "array",
      items: {
        type: "object",
        properties: {
          title: { type: "string" },
          url: { type: "string" }
        },
        required: ["title", "url"],
        additionalProperties: false
      }
    },
    proactiveMessage: { type: ["string", "null"] }
  },
  required: ["reply", "suggestedLinks", "proactiveMessage"],
  additionalProperties: false
};

function buildStoreContext(data) {
  return {
    business: data.business,
    policies: data.business?.policies || {},
    pages: data.pages?.pages || [],
    products: data.products?.products || [],
    shipping: data.shipping || {},
    faq: data.faq?.items || [],
    recipes: data.recipes?.recipes || []
  };
}

function extractDestination(text) {
  const normalized = normalizeText(text);
  const stateMatch = normalized.match(/\b(a[lkz]|c[aot]|d[ce]|f[ml]|g[au]|h[i]|i[adl]|k[sy]|l[a]|m[aedihnopyt]|n[cejhvy]|o[hkr]|p[aer]|r[i]|s[cd]|t[nx]|u[t]|v[a]|w[aiv])\b/);
  if (stateMatch) {
    return stateMatch[0].toUpperCase();
  }
  if (normalized.includes("international")) {
    return "international";
  }
  return "";
}

function buildSignals({ message, cartItems, data }) {
  const normalized = normalizeText(message || "");
  const signals = {
    wantsTracking: includesAny(normalized, ["track", "tracking", "order status"]),
    wantsReturns: includesAny(normalized, ["return", "returns", "refund"]),
    wantsShipping: includesAny(normalized, ["shipping", "deliver", "delivery", "ship fast", "ship"]),
    wantsCartRecommendation: includesAny(normalized, ["what else", "recommend", "add on", "addon", "upsell"])
  };

  const destination = signals.wantsShipping ? extractDestination(normalized) : "";
  const shippingHint = destination ? shippingEstimate(destination, data) : null;

  const pageMatch = routeToPage(normalized, data);
  const faqMatch = signals.wantsTracking ? faqAnswer("tracking", data) : faqAnswer(normalized, data);
  const intentMatch = recommendForIntent(normalized, data);
  const productMatches = searchProducts(normalized, {}, data);
  const cartSuggestions =
    signals.wantsCartRecommendation && cartItems?.length
      ? recommendFromCart(cartItems, data)
      : [];
  const pages = data.pages?.pages || [];
  const linkHints = {
    shop: pages.find((page) => page.id === "shop"),
    subscriptions: pages.find((page) => page.id === "subscriptions"),
    shipping: pages.find((page) => page.id === "shipping"),
    returns: pages.find((page) => page.id === "returns"),
    contact: pages.find((page) => page.id === "contact")
  };

  return {
    normalized,
    destination,
    shippingHint,
    pageMatch,
    faqMatch,
    intentMatch,
    productMatches,
    cartSuggestions,
    linkHints
  };
}

function buildAllowedLinks(data) {
  const links = new Map();
  for (const page of data.pages?.pages || []) {
    if (page?.url && page?.title) {
      links.set(page.url, page.title);
    }
  }
  for (const product of data.products?.products || []) {
    if (product?.url && product?.name) {
      links.set(product.url, product.name);
    }
  }
  const supportUrl = data.business?.support?.helpCenterUrl;
  if (supportUrl) {
    links.set(supportUrl, "Help Center");
  }
  return links;
}

function sanitizeLinks(links, allowedLinks) {
  if (!Array.isArray(links)) {
    return [];
  }
  const cleaned = [];
  for (const link of links) {
    if (!link?.url) {
      continue;
    }
    if (!allowedLinks.has(link.url)) {
      continue;
    }
    cleaned.push({
      title: link.title || allowedLinks.get(link.url),
      url: link.url
    });
    if (cleaned.length >= 4) {
      break;
    }
  }
  return cleaned;
}

function buildMessages({ message, proactiveTrigger, storeContext, cartItems, history, signals }) {
  const system = [
    "You are an AI support agent for a WooCommerce store.",
    "All answers must be generated by OpenAI using ONLY the provided store data.",
    "Do not invent policies, prices, or URLs. If the data is missing, say you do not have that information and offer the best support option from the data.",
    "Answer questions about products, pages, policies, shipping, and order tracking steps.",
    "Suggest links to the correct pages (shop, subscriptions, shipping, returns, contact) when relevant.",
    "Use shipping rules from the data for shipping speed questions.",
    "Suggest products based on cart items when cartItems are provided.",
    "Suggest products for a situation using use-cases, tags, and recipe rules from the data.",
    "Be concise, friendly, and specific. Offer a short follow-up question when it helps.",
    "If proactiveTrigger is set and the user message is empty, produce a short proactiveMessage and leave reply empty."
  ].join(" ");

  const developer = [
    "Return JSON only using the provided schema.",
    "Use suggestedLinks for relevant product or page URLs from the data.",
    "Suggested links must match exact URLs from the data.",
    "If signals.shippingHint is present, use its method/minDays/maxDays/note for shipping speed answers.",
    "If signals.cartSuggestions is present, use those products for cart upsells.",
    "If signals.intentMatch is present, use its products/recipes for situation-based suggestions.",
    "If signals.pageMatch is present, summarize it and link to it.",
    "If signals.linkHints contains a relevant page, suggest that link.",
    "If signals.faqMatch is present for tracking or policy questions, use it."
  ].join(" ");

  const input = [];
  input.push({ role: "system", content: system });
  input.push({ role: "developer", content: developer });
  input.push({
    role: "developer",
    content: `Store data (JSON): ${JSON.stringify(storeContext)}`
  });
  input.push({
    role: "developer",
    content: `Derived signals (JSON): ${JSON.stringify(signals)}`
  });
  if (cartItems?.length) {
    input.push({
      role: "developer",
      content: `Cart items (product IDs): ${JSON.stringify(cartItems)}`
    });
  }
  for (const entry of history || []) {
    input.push(entry);
  }

  input.push({
    role: "user",
    content: JSON.stringify({
      message: message || "",
      proactiveTrigger: proactiveTrigger || null
    })
  });

  return input;
}

export async function runAgent({ message, cartItems, storeOverride, proactiveTrigger, sessionState }) {
  const data = applyStoreOverride(loadData(), storeOverride);
  const storeContext = buildStoreContext(data);
  const allowedLinks = buildAllowedLinks(data);
  const history = sessionState.history || [];
  const signals = buildSignals({ message, cartItems, data });

  const response = await client.responses.create({
    model: DEFAULT_MODEL,
    input: buildMessages({
      message,
      proactiveTrigger,
      storeContext,
      cartItems,
      history,
      signals
    }),
    text: {
      format: {
        type: "json_schema",
        name: "store_reply",
        strict: true,
        schema: RESPONSE_SCHEMA
      }
    }
  });

  const outputText = response.output_text || "";
  let parsed;
  try {
    parsed = JSON.parse(outputText);
  } catch (error) {
    parsed = {
      reply: "",
      suggestedLinks: [],
      proactiveMessage: null
    };
  }

  return {
    reply: parsed.reply || "",
    suggestedLinks: sanitizeLinks(parsed.suggestedLinks, allowedLinks),
    proactiveMessage: parsed.proactiveMessage || null
  };
}
